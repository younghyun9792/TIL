# **GDB 사용법**

<br>

### `GDB(GNU Debugger)`란 [GNU](GNU란.md) 소프트웨어 시스템을 위한 기본 디버거로, 이와 같은 디버거의 목적은 **다른 프로그램 수행 중 그 프로그램 내부에서 무슨 일이 일어나고 있는지, 혹은 프로그램에서 오류가 일어났을 때 어떤 일이 일어났는지를 보여주는 것**이다.

<br><br>

- - -

<br>

## **사용법**

<br>

```C
// debugge.c
#include <stdio.h>
int main(void) {
  int sum = 0;
  int val1 = 1;
  int val2 = 2;
  sum = val1 + val2;
  printf("1 + 2 = %d\\n", sum);
  return 0;
}
```
### 위와 같은 C언어 파일이 있을 때, GDB를 이용해 분석 하려면 먼저 컴파일을 하고, 디버깅을 시작한다.

<br>

```
gcc -o debugee debugee.c // 컴파일
gdb debugee
```

<br><br>

## **start**

### 리눅스는 실행파일의 형식으로, `ELF(Executable and Linkable Format)`를 규정하고 있는데, ELF의 헤더 중 **진입점(Entry Point, EP)** 라는 필드가 있다.
### 운영체제는 ELF를 실행할 때, 진입점(Entry Point)의 값부터 프로그램을 실행한다.

<br>

### gdb의 `start` 명령어는 진입점부터 프로그램을 분석할 수 있게 해주는 명령어로, DISASM 영역의 화살표(►)가 가리키는 주소는 현재 `rip`의 값인데, start 명령어를 실행하고 보면 readelf에서 알아본 진입점(Entry Point)과 일치한다.

<br><br>

## **context**

### 프로그램은 실행되면서 레지스터를 비롯한 여러 메모리에 접근하는데, 즉 디버거를 이용하여 프로그램의 실행 과정을 관찰하려면 컴퓨터의 각종 메모리를 한눈에 파악할 수 있는 게 좋다.

### pwndbg는 주요 메모리들의 상태를 프로그램이 실행되고 있는 **맥락(Context)** 이라 부르며, 이를 가독성 있게 표현할 수 있는 인터페이스를 갖추고 있고, 크게 4개의 영역으로 나눠진다.

<br>

### **`registers`**
### 레지스터의 상태를 보여준다. 
<br>

### **`disasm`**
### rip부터 여러 줄에 걸쳐 디스어셈블된 결과를 보여준다.
<br>

### **`stack`**
### rsp부터 여러 줄에 걸쳐 **스택의 값**들을 보여준다.
<br>

### **`backtrace`**
### 현재 rip에 도달할 때까지 어떤 함수들이 중첩되어 호출됐는지 보여준다.

<br>

![](https://velog.velcdn.com/images/younghyun/post/70b5a6cc-436e-4a8b-b90e-ae93d338bfff/image.png)

<br><br>

## **break & run**

### gdb를 이용하여 프로그램을 분석할 때, 보통 전체 프로그램 중 일부의 동작에만 관심이 있는데, `break`은 특정 주소에 **중단점(breakpoint)** 을 설정하는 기능이고, `continue`는 중단된 프로그램을 **계속 실행시키는** 기능이다.

<br><br>

## **run**

### start가 진입점부터 프로그램을 분석할 수 있도록 자동으로 중단점을 설정해줬다면, `run`은 단순히 실행만 시킨다.
### 즉, 중단점(breakpoint)를 따로 설정하지 않았다면, 프로그램이 끝까지 실행된다.

<br><br>

## **disassembly**
### gdb는 프로그램을 **어셈블리 코드 단위**로 실행하고, 결과를 보여준다.

### 하지만, 프로그램의 코드는 기계어로 이루어져 있는데, 즉gdb는 기계어를 **디스어셈블(Disassemble)** 하는 기능을 기본적으로 탑재하고 있는데, pwndbg에는 디스어셈블된 결과를 가독성있게 출력해주는 기능이 있다.

<br>

### `disassemble` 명령어는 gdb가 기본적으로 제공하는 디스어셈블 명령어로, 함수 이름을 인자로 전달하면 해당 함수가 반환될 때 까지 디스어셈블하여 보여준다.

<br>

### 그 외에도 `u`, `nearpc`, `pdisassemble`은  pwndbg에서 제공하는 디스어셈블 명령어로, 디스어셈블된 코드를 가독성 좋게 출력해준다.

<br><br>

## **navigate**
### 관찰하고자 하는 함수의 중단점에 도달했으면, 그 지점부턴 명령어를 한 줄씩 자세히 분석해야 한다.

<br>

### 이때 사용하는 명령어로 `ni`과 `si`가 있는데, 둘 모두 어셈블리 명령어를 한 줄 실행하지만 call 등을 통해 서브루틴을 호출하는 경우 **ni는 서브루틴의 내부로 들어가지 않지만 si는 서브루틴의 내부로 들어간다.**

<br>

### 즉, 프로그램을 분석하다가 어떤 함수의 내부까지 궁금할 땐 `si`를, 그렇지 않을 떈 `ni`를 사용하는데, `si`로 함수 내부에 들어가서 모두 분석했을 때 함수의 끝까지 실행하는 명령어로 `finish`가 있다.

<br><br>




## **examine**

<br>

### 프로그램을 분석하다 보면 가상 메모리에 존재하는 임의 주소의 값을 관찰해야할 때가 있는데, 이를 위해 gdb에서는 기본적으로 x라는 명령어를 제공한다. x를 이용하면 **특정 주소**에 있는 **원하는 길이만큼**의 데이터를 **원하는 형식으로** 인코딩하여 볼 수 있다.

<br>

### **x/'범위','출력형식','범위의단위' '메모리주소 혹은 함수명'** 의 구조로 이루어져 있다.
### 범위에 오는 수 * 범위의 단위 byte 만큼 출력한다.
### 출력 형식으론 `x(hex)`, `s(str)`, `I(Instruction)`이 올 수 있다.
### 범위의 단위로는 `b(1byte)`, `h(2byte)`, `w(4byte)`,`g(8byte)`가 올 수 있다.

### 아래는 예시이다.  
<br>

```
x/10gx $rsp -> rsp부터 80바이트를 8바이트씩 hex 형식으로 출력
x/5i $rip -> rip부터 10줄의 어셈블리 명령어 출력
x/s 0x400000 -> 0x400000 주소의 문자열 출력
```

<br><br>

## **telescope**
### `telescope`는 특정 주소의 메모리 값들을 보여주는 것에서 그치지 않고 **메모리가 참조하고 있는 주소**를 재귀적으로 탐색하여 값을 보여준다.

<br><br>

## **vmmap**
### `vmmap`은 **가상 메모리의 레이아웃**을 보여준다. 어떤 파일이 매핑된 영역일 경우 해당 파일의 경로까지 보여준다.