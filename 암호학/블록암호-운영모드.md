# **블록암호-운영모드**

<br>

* ### DES나 AES같은 블록 암호는 한번에 한 블록의 평문을 암호화하기 위해 설계되었는데, DES는 64비트, AES는 128비트의 평문을 한 블록으로 처리한다. UTF-8로 인코딩할 때 알파벳 한 글자는 8비트에 대응되므로 DES와 AES는 각자 8글자, 16글자를 한 번에 암호화할 수 있다.

* ### 그런데, 일반적으로 사용되는 평문의 길이는 이 길이들을 넘는 경우가 많은데, 운영 모드(Mode of Operation)는 블록 암호로 이러한 다양한 크기의 데이터를 처리할 수 있도록 고안된 블록 암호의 사용 방법이다.

* ### 운영 모드에는 여러 종류가 있으며, 블록 암호를 사용하는 서비스는 각자의 장단점을 고려하여 운영 모드를 선택한다.


<br><br>

## **패딩**

- - -

<br>

* ### 블록 암호는 블록 단위로 암호화를 하므로, 입력의 길이가 정확하게 블록 크기의 배수가 되어야하는데, 일반적으로 평문의 크기는 블록 크기의 배수가 되지 않는다.
* ### 이런 문제를 해결하기 위해 평문에 데이터를 붙여서 평문의 크기가 블록 크기의 배수가 되도록 만드는 과정을 **패딩(Padding) 이라고 한다.
* ### 패딩된 암호문을 복호화할 때는 복호화된 평문에서 패딩을 제거해야 평문을 얻을 수 있고, 즉 패딩된 암호문의 수신자는 어떤 패딩이 적용됐는지 알아야 암호문을 복호화할 수 있다.

<br><br>

## 비트 패딩

<br>

* ### 비트 패딩(Bit Padding)은 마지막 블록에서 평문이 채우지 못하는 비트 중 최상위 비트를 1로 설정하고, 나머지는 모두 0으로 채우는 패딩 기법이다.

* ### 수신자는 평문의 마지막 비트부터 처음으로 값이 1인 비트가 나올 때까지를 패딩으로 인식하며, 이를 제거하여 평문을 얻을 수 있다.

<br>

```
1011 1011 1111 0111 | 1011 0110 1000 0000
```


<br>



* ### 이 방법은 평문의 크기가 정확히 블록 크기의 배수일 때 수신자가 메세지의 일부를 패딩으로 오인하게 되는 문제가 있는데, 이를 막기 위해 비트 패딩을 적용할 때에는 평문의 크기가 블록 크기가 배수이면, 패딩으로 한 블록을 추가한다.

<br>

```
1011 1011 1111 1011 | 1011 0000 0000 0000
```

<br>

* ### 이와 같이, 마지막 한 블록을 패딩으로 인식하여 제거 한다.

<br><br>

## 바이트 패딩:ANSI X.923

<br>

* ### 바이트 패딩(Byte Padding)은 바이트 단위로 패딩을 수행하는 패딩 기법이며, 여러 종류가 있다.
* ### 그 중에서 ANSI X.923은 마지막 블록의 남는 바이트를 임의의 값(일반적으로 0)으로 채우고, 마지막 바이트에 패딩의 길이를 기록하는 기법이다.

* ### 아래의 경우는 마지막 바이트의 값이 4이므로 마지막 네 바이트(00 00 00 04)가 패딩이 된다.

```
A3 B2 91 81 50 23 00 00 14 50 00 00 00 00 00 04
```

<br>

* ### ANSI X.923은 비트 패딩과 마찬가지로 평문의 크기가 블록 크기의 배수일 때, 수신자가 평문을 패딩으로 오인할 수 있으므로 따라서 평문의 크기가 블록 크기의 배수일 때는 마지막에 한 블록을 패딩으로 추가한다.

<br><br>

## 바이트 패딩: PKCS#7

<br>

* ### PKCS(Public-Key Cryptographt Standard)는 공개키 암호의 표준 문서로서, 그중 7번째 문서인 PKCS#7은 AES와 같은 블록 암호의 패딩 기법을 제시한다.

* ### PKCS#7에 소개된 패딩 기법은 추가할 패딩의 바이트 크기로 마지막 블록을 채우는 패딩 기법인데, 아래에서는 마지막 블록에 4바이트를 패딩한 것이다.

<br>

```
A3 B2 91 81 50 23 00 00 ∣ 14 50 00 00 04 04 04 04
```

<br>

* ### 다른 패딩 기법들과 마찬가지로 평문의 크기가 블록 크기의 배수이면 PKCS#7 아래를 패딩으로 추가한다.

```
08 08 08 08 08 08 08 08
```

<br><br><br>

## **운영 모드**

<br><br>

## ECB 모드

<br>

* ### 블록 암호로 평문을 암호화할 떄 평문은 패딩을 거친 후 여러 블록으로 나뉜다. 그리고, 각각의 블록은 블록 암호의 운영 모드에 따라 암호화된다.

* ### ECB(Electronic Code Book) 모드는 가장 간단한 운영모드로, 블록들은 모두 같은 키로 암호화된다.

* ### ECB 모드에서는 각블록이 독립적으로 암호화되므로 여러 블록을 병렬적으로 암호화할 수 있다는 장점이 있으나, ECB는 다른 운영모드에 비해 암호학적 안전성이 부족하다는 단점이 있다.

<br>

![이미지](https://kr.object.ncloudstorage.com/dreamhack-content/page/dc7a5156e28483047d817aca0fd5c79c1c8a02a2a03f8adbbdc9069a24e5656c.png)


<br>

* ### ECB 모드를 사용하면, 같은 블록은 같은 암호문으로 암호화되는데, 이 특징을 이용하면 공격자는 암호문에서 평문의 정보를 습득하거나, 재전송 공격(Replay Attack)을 수행하는 것이 가능해진다.

* ### 이미지의 한 픽셀을 한 블록으로 하여 ECB 암호화하면 같은 픽셀들은 모두 같은 픽셀로 암호화되므로 원본 이미지의 패턴이 암호화된 이미지에도 그대로 나타난다.

* ### 이는 암호문으로부터 평문의 정보를 유추하기 어려워야 한다는 혼돈 성질이 약함을 의미한다.

<br><br>

## CBC 모드

<br>

* ### CBC(Cipher Block Chaining)모드는 어떤 블록을 암호화하기 전에, 이 블록을 직전 블록의 암호문과 XOR하는데, 평문의 첫 번째 블록은 이전 블록이 존재하지 않으므로 초기 벡터(Initialization Vector, IV)라고 불리는 임의의 데이터와 XOR한다. 이 모드를 사용하면 각 블록이 서로의 암호화에 영향을 주므로 같은 블록도 전체 평문 및 IV에 따라 암호화 결과가 달라진다.

* ### 송신자는 초기 벡터를 암호문의 0번쨰 블록 C0으로 전송하고, CBC 모드의 암복호화를 수학적으로 표현하면 다음과 같다.

![이미지](https://velog.velcdn.com/images/as979200/post/35aebec2-1951-4ba3-b9f5-122f8160c25a/image.png)



<br>



* ### 초기 벡터는 일반적으로 논스(Nonce, number used only once)라는 무작위 값을 사용하며, 이는 공격자가 알아도 안전성에 영향을 끼치지 않는다.
  
* ### 그러나 만약, 공격자가 암호문을 중간에 가로채서 이를 조작할 수 있다면, 복호화 결과의 첫 번째 블록을 조작할 수 있다.

* ### CBC 모드는 한 블록을 암호화할 때 직전 블록의 암호화 결과를 사용하므로 여러 블록을 병렬적으로 암호화할 수 없다. 그러나 복호화의 경우, 모든 암호문 블록을 알고 있으므로 병렬적으로 처리할 수 있다.

* ### CBC모드는 재전송 공격에 강인하며, 높은 혼돈성을 가지고 있어서 블록 암호의 운영 모드로 널리 사용되고 있다.

<br>

![이미지](https://kr.object.ncloudstorage.com/dreamhack-content/page/c40222dfbfb8e9b98167b0e206247ce4292a16ffd958710ef0b6deba043927ae.png)

<br><br>

## CTR모드

<br>

* ### CTR(Counter)모드는 블록 암호에 nonce와 평문 블록의 인덱스(counter)를 결합한 값을 입력하는데, 암호문은 블록 암호의 출력과 평문 블록을 XOR하여 생성한다.

* ### CTR 모드의 암복호화를 수학적으로 나타내면 아래와 같다. ||는 두 바이트의 배열을 결합하는 기호이다.

![이미지](https://velog.velcdn.com/images/as979200/post/a58381cc-b18c-4384-babe-2a1d10cc2a1a/image.png)

* ### CTR 모드는 블록을 순서대로 암복호화하지 않아도 되므로, 병렬로 암복호화할 수 있으며 구현이 간단하다는 장점이 있다.

![이미지](https://kr.object.ncloudstorage.com/dreamhack-content/page/904534ce16bbadac59da5f368c1be0fc933abb9455c8d2fc752f6e9f819a69e1.png)