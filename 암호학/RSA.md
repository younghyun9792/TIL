# **RSA**

<br>

* ### RSA 암호 알고리즘은 공개키 암호 시스템의 하나로, 전자 거래, 금융 거래, 인증서 등 다양한 분야에서 가장 보편적으로 사용되는 암호 및 인증 알고리즘이다.

<br>

* ### RSA 알고리즘은 1978년 MIT의 대학원생인 Ronald L.Rivest와 Adi Shamir, 그들의 지도 교수인 Leonard Adleman의 연구로 체계화된 알고리즘이며, RSA라는 이름은 그들의 이름 첫 글자를 이어 붙인 것이다.

<br>

* ### RSA는 1983년에 특허로 등록되었는데, 현재는 특허 기간이 만료되어 공공 및 민간 분야에서 널리 사용되고 있다.

<br>

* ### RSA 암호 알고리즘의 안전성은 아주 큰 두 소수의 곱으로 이루어진 합성수를 인수분해하기 어렵다는 인수분해 문제의 어려움에 기반하기 때문에, RSA로 암호화할 때는 합성수의 소인수분해가 어려워지도록 각 인자를 적절히 설정해야 한다.

<br>

* ### RSA는 암복호화 과정에서 AES를 비롯한 대칭키 암호 알고리즘보다 훨씬 많은 연산을 필요로 해서, 많은 데이터를 여러 번 암호화해야 하는 네트워크 통신에서는 잘 사용하지 않는다.

<br><br>

- - -

<br>

## **RSA 암호 알고리즘**

<br>

* ### RSA 암호 알고리즘은 대칭키 암호와 달리 두개의 키가 사용되는 비대칭키 암호 방식이다.

<br>

## 오일러 정리

<br>

* ### RSA를 이해하려면 오일러 정리에 대해 알아야 하는데, 오일러 정리는 n 과 서로소인 양의 정수 m이 다음 식을 만족한다는 정리이다.

<br>

![이미지](https://velog.velcdn.com/images/as979200/post/15529929-2454-4145-8d59-29133bae8d37/image.png)

<br>

* ### 여기서 φ(n)은 오일러 파이 함수(Euler's phi function)라고 불리며, n 이하의 양의 정수 중에서 n과 서로소인 수의 개수를 의미한다.

<br>

* ### 예를 들어 6 이하의 양의 정수 중 6과 서로소인 수는 1,5로 두 개이기 때문에 φ(6) = 2 이고, 소수 p의 경우에는 1부터 p-1까지 모두 p와 서로소이기 때문에 φ(p) = p -1가 된다.

<br>

## 키 생성

<br>

* ### 공개키 암호 알고리즘에서는 공개키와 개인키를 생성하는 키 생성 과정이 필요한데, 대칭키 암호 알고리즘에서는 임의의 난수를 선택하면 됐지만 RSA는 인수분해를 어렵게 만들기 위해 복잡한 연산을 거쳐야 한다.

<br>

* ### 먼저 서로 다른 두 소스 p와 q를 선택한다. 일반적으로 1024비트 이상에서 비트 길이가 같은 수로 선택한다.

* ### 그 뒤 p와 q를 곱하여 n을 구하고 φ(n)을 계산한다.

```
n = p x q
```

<br>

* ### n = p x q인데 p와 q가 소수이므로 φ(n)은 n보다 작으면서 p와 q의 배수가 아닌 수들의 개수가 된다. n 이하의 수 중 p의 배수는 q개, q의 배수는 p개 존재하며 이 중 같은 수는 두 수의 최소공배수인 n뿐이다. 따라서 φ(n)은 다음과 같은 식으로 표현할 수 있다.

```
φ(n) = p x q - p - q + 1 = (p-1)(q-1)
```

<br>

* ### φ(n)을 구한 뒤, φ(n)보다 작은 수 중 φ(n)과 서로소인 e를 선택하고 d≡e의 -1제곱 mod φ(n)인 d를 구한다.

```
e < φ(n), gcd(e,φ(n)) = 1
d ≡ e의 -1제곱(% φ(n))
```

<br>

* ### 위 과정으로 생성한 값들 중, n과 e는 공개키로 d는 개인키로 사용 된다. n은 modulus, e는 공개 지수(Public exponent), d는 비밀 지수(Private exponent)라고 불린다.

<br>

* ## 암호화

<br>

* ### 공개키(n,e)로 n보다 작은 평문 m을 암호화할 때 암호문 c는 다음 식으로 구해진다.

```
C≡m의 e제곱(mod n)
```

<br>

## 복호화

<br>

* ### 암호문 c를 개인키 d로 복호화할 때, 평문 m은 다음과 같이 구해질 수 있다.

```
m ≡ c의 d제곱(mod n)
c의 d제곱 ㅍ (m의e제곱)d제곱 ㅍ m의 ed제곱 (mod n)
```

<br>

* ### 오일러 정리에 따르면 d ≡ e의 -1제곱 (mod φ(n))이므로 ed = kφ(n) + 1 을 만족하는 자연수 k가 존재한다. 따라서 다음 등식이 성립한다.

<br>

![이미지](https://velog.velcdn.com/images/as979200/post/f0de0ee4-82f8-4e62-bcb7-f4b02cc00c06/image.png)

<br><br>

## Coppersmith 공격

<br>

* ### Coppresmith 정리에 따르면 차수가 e인 함수 f(x)에서 찾고자 하는 근이 n의 e분의1제곱보다 작을 경우 복잡도가 O(log n)인 알고리즘을 이용하여 근을 구할 수 있다.

* ### 이를 RSA에 적용할 경우 근이 e분의1보다 작은 함수 f(x)를 만들 수 있다면 평문을 얻어낼 수 있다. 예를 들어 e=3이고 평문의 비트 중 상위 3분의2 이상을 알고 있고 이를 a라고 한다면 f(x) = (a+x)의 3제곱을 만들어 Coppersmith 정리를 사용해 전체 평문을 얻어낼 수 있다.

<br>

## Hastad's Broadcast 공격

<br>

* ### 이 공격은 한 송신자가 다수의 송신자에게 동일한 평문을 전송할 때, 수신자들에게 모두 동일한 작은 e 값을 사용할 경우 가능한 공격 방법이다.

* ### 예를 들어 공개키 e=3을 가진 3명의 수신자들에게 같은 평문 m을 암호화해서 보내는 경우 수신자들은 서로 서로소인 n을 사용하고 이를 n1,n2,n3로 표기하면 각 수신자들에게 얻은 암호문을 c1,c2,c3라고 했을 떄 아래 3개의 수식을 얻을 수 있다.

```
m³ ≡ c1 (mod n1)
m³ ≡ c2 (mod n2)
m³ ≡ c3 (mod n3)
```

<br>

* ### 각 n이 서로 서로소이기 때문에 위 3개의 수식을 중국인의 나머지 정리를 이용해 합치면 아래의 수식을 얻을 수 있다.

```
m³ ≡ (mod n1n2n3)
```

<br>

* ### 여기서 각 n의 값이 모두 m보다 크기 때문에 m³ < n1n2n3이 성립하고, 위의 식에서 m³ = c 라는 등식을 얻을 수 있다.

* ### c는 위에서 중국인의 나머지 정리를 이용해 구한 값이므로 위등식으로 평문 m을 구할 수 있다.

<br>

## Common Modulus Attack

<br>

* ### Common Modulus Attack은 같은 n과 서로소인 두 공개 지수 e1,e2를 사용하여 같은 평문 m을 암호화해서 두 암호문 c1,c2을 만들었을 때, 이를 공격하는 기법이다.

* ### 공격자는 두 공개 지수가 서로소라는 점을 활용해 re1 + se2 = 1이고, r이 음수인 (r,s)쌍을 확장 유클리드 알고리즘을 통해 구하고, 확장 유클리드 알고리즘을 사용해 c1의 -1제곱 (mod n)을 구한다.

* ### 계산된 값을 바탕으로 아래의 수식으로 m을 구할 수 있다.

<br>

![이미지](https://velog.velcdn.com/images/as979200/post/bff4e9e6-e231-4dfe-9567-9b47b424c6fa/image.png)

<br>

* ### 이처럼 수신자들이 같은 n을 사용하면 쉽게 공격당할 수 있으므로 수신자들은 n을 무작위 값으로 생성해서 사용해야 한다.