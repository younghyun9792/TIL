# **Stack Buffer Overflow**

<br>

`Stack Buffer Overflow`는 `Stack`의 `Buffer`에서 발생하는 `Overflow`를 뜻한다.

<br>

### **Buffer**
<br>

버퍼는 일상에서 '완충 장치'라는 뜻으로, 컴퓨터 과학에서는 '데이터가 목적지로 이동되기 전에 보관되는 임시 저장소'의 의미로 쓰인다.

<br>

데이터의 처리속도가 다른 두 장치가 있을 때, 이 둘 사이에 오가는 데이터를 임시로 저장해 둘 시 일종의 완충 작용을 한다.  

<br>

예를 들어, 키보드에서 데이터가 입력되는 속도보다 데이터의 처리 속도가 느린 프로그램이 있으면, 키보드의 입력 중 프로그램에서 수용하지 못한 데이터는 모드 사라질 것이지만 이런 문제를 해결하기 위해 송수신 측에 `Buffer` 라는 임시 저장소를 두고 이를 통해 간접적으로 데이터를 전달한다.

<br>

송신 측에서 버퍼로 데이터를 전송하고, 수신 측에서 버퍼에서 데이터를 꺼내 사용하는데, 이러면 버퍼가 가득 차기 전까진 데이터의 유실 없이 사용할 수 있으며, 완충 작용이 된다.  

<br>

현대에는 이런 완충의 의미가 많이 희석되어 저장될 수 있는 모든 단위를 버퍼라고 부르기도 하며, 스택에 있는 지역 변수는 **'스택 버퍼'**, 힙에 할당된 메모리 영역은 **'힙 버퍼'** 라고 불린다.

<br><br><br>

---
<br>

## **버퍼 오버플로우**

<br>

**버퍼 오버플로우(Buffer Overflow)** 는 문자 그대로 버퍼가 넘치는 걸 의미한다.  
버퍼는 각자 크기를 가지고 있는데, `int` 변수는 4 byte, 10개의 원소를 갖는 `char` 배열은 10 byte의 크기를 갖는다.  
만약 10 byte 크기의 버퍼에 20 byte 크기의 데이터가 들어가려 할 시 오버플로우가 발생한다.   

<br>

일반적으로 버퍼는 메모리상에 연속해서 할당되어 있으므로, 어떤 버퍼에서 오버플로우가 발생 시 뒤의 버퍼들의 값이 조작될 위험이 있다. 스택 영역에서 버퍼 오버플로우가 일어날 시 **중요 데이터 변조**, **데이터 유출**, **실행 흐름 조작** 등의 여러 공격을 당할 수 있다.

<br>

또한, `ret(Return Address)`이라는 함수가 호출되고 원래 함수로 돌아가기 위한 **복귀 주소**를 조작하게 될 시 버퍼에 쉘코드 작성 후 버퍼를 `ret`에 삽입 시 쉘코드가 실행되거나, 다른 위험한 함수들의 주소 등을 넣을 수 있게 된다.

<br><br>

---

<br>


## **Buffer Overflow 대응책**

<br>
<br>

+ ### 취약하지 않은 함수 사용

    `strcpy`, `strcat`, `scanf` 등 몇몇 함수는 입력값의 길이를 검사하지 않아 취약한데 `strncpy`, `strncat` 함수 사용과 scanf 함수의 버퍼 크기 지정 등 입력 값의 길이를 명시해 주어야 한다.

<br>

+ ### **스택 가드(Stack Guard)**
  
  `ret`과 변수 사이에 특정 값(Canary word)를 저장해 두고, 해당 값이 조작되었으면 버퍼 오버플로우로 판단하여 프로그램을 종료하는 기법이다.

<br>

+ ### **스택 쉴드(Stack Shild)**
  
  함수 호출 시 `ret`을 `Global RET`이라는 특수 스택에 저장 후, 함수를 종료할 때 `ret`과 `Global RET`의 값을 비교하여 값이 다를 시 프로그램을 종료하는 기법이다.

<br>

+ ### **ASLR(Address Space Layout Randomization)**
  
  직역하면 **"주소 공간 배열 무작위화"** 로, 메모리 공격을 어렵게 하기 위해 프로그램을 실행할 때마다 데이터영역(스택, 힙, 라이브러리...)의 주소를 무작위화 시키는 기법이다.
  
  <br>

+ ### **NX(None Excute) bit**
  
  스택/ 힙 영역의 **실행 권한을 제거**하여 쉘의 실행을 방지하는 기법이다.